# Conversion Result: skill-sdd-tools-execute-tdd-tasks

## Metadata

| Field | Value |
|-------|-------|
| Component ID | skill-sdd-tools-execute-tdd-tasks |
| Component Type | skill |
| Group | sdd-tools |
| Name | execute-tdd-tasks |
| Source Path | claude/sdd-tools/skills/execute-tdd-tasks/SKILL.md |
| Target Path | skills/execute-tdd-tasks.md |
| Fidelity Score | 68% |
| Fidelity Band | yellow |
| Status | partial |

## Converted Content

~~~markdown
---
description: Execute TDD task pairs autonomously with RED-GREEN-REFACTOR verification. Orchestrates wave-based execution with strategic parallelism, routing TDD tasks to tdd-executor agents and non-TDD tasks to standard task-executor. Use when user says "execute tdd tasks", "run tdd tasks", "start tdd execution", or wants to execute TDD-paired tasks from create-tdd-tasks. Note: this skill requires a primary-agent context — the question tool used for plan confirmation is not available in subagent contexts.
user-invocable: true
---

# Execute TDD Tasks Skill

Arguments: `[--task-group <group>] [--max-parallel <n>] [--retries <n>]`

- `--task-group <group>`: Optional task group name to filter tasks. Only tasks with matching metadata.task_group will be executed.
- `--max-parallel <n>`: Maximum number of tasks to execute simultaneously per wave. Default is 5. Overrides settings file value.
- `--retries <n>`: Number of retry attempts for failed/partial tasks before moving on. Default is 3.

This skill orchestrates autonomous execution of TDD task pairs generated by `/create-tdd-tasks`. It is the TDD counterpart to the standard `execute-tasks` skill, reusing its session management, wave infrastructure, and execution context sharing while adding TDD-specific agent routing, RED-GREEN-REFACTOR verification, and per-task compliance reporting.

The key difference from standard `execute-tasks`: this skill routes TDD tasks to the `tdd-executor` agent (from `tdd-tools`) which runs a 6-phase TDD workflow, while routing non-TDD tasks to the standard `task-executor` agent. It verifies TDD compliance (RED verified, GREEN verified, refactored) per task pair and reports aggregate results.

**CRITICAL: Complete ALL 10 steps.** The workflow is not complete until Step 10: Update CLAUDE.md is evaluated. After completing each step, immediately proceed to the next step without waiting for user prompts (except Step 6 which requires user confirmation).

## Cross-Plugin Dependency

This skill requires the `tdd-tools` plugin to be installed. It uses:
- **tdd-executor** agent (Opus) -- 6-phase TDD workflow per task
- **test-writer** agent (Sonnet) -- parallel test generation (used by tdd-executor internally)

If `tdd-tools` is not installed, this skill MUST abort with a clear error before launching any agents. See Step 2 for the detection and error handling procedure.

## Core Principles

### 1. TDD Compliance First

Every TDD task pair must complete the RED-GREEN-REFACTOR cycle:
- **RED**: Tests are written and verified to fail before any implementation exists
- **GREEN**: Implementation is written that makes all tests pass with zero regressions
- **REFACTOR**: Code is cleaned up while keeping all tests green

### 2. Strategic Parallelism

Maximize execution throughput without violating TDD sequencing:
- **PARALLEL**: Multiple test-writing tasks (RED phase) run simultaneously across features
- **SEQUENTIAL**: Within a single TDD pair, RED must complete before GREEN can start (enforced by dependencies)

### 3. Reuse execute-tasks Infrastructure

Session management, wave execution, context sharing, and progress tracking all reuse the same patterns from `execute-tasks`. See the TDD execution workflow reference (Step 1) for TDD-specific extensions.

### 4. Honest TDD Reporting

Report per-task compliance with the full RED-GREEN-REFACTOR cycle:
- `red_verified`: Whether tests failed as expected before implementation
- `green_verified`: Whether all tests pass after implementation
- `refactored`: Whether code was cleaned up while maintaining green tests
- `coverage_delta`: Change in test coverage percentage (if measurable)

## Orchestration Workflow

This skill orchestrates TDD task execution through a 10-step loop that mirrors the standard `execute-tasks` orchestration with TDD-specific extensions. See the TDD execution workflow reference for the full TDD wave execution details and the TDD verification patterns reference for TDD phase verification rules.

### Step 1: Load References

<!-- TODO: Reference file inlining required. The following reference files are used by this skill but opencode has no reference_dir equivalent. Inline their content into this skill body or register them in opencode.json under the instructions array. Reference files: tdd-execution-workflow.md and tdd-verification-patterns.md (both in the original claude/sdd-tools/skills/execute-tdd-tasks/references/ directory). -->

Read the TDD-specific reference files containing the full wave execution workflow and verification rules. These files must be inlined into this skill or loaded via the opencode.json instructions config:

- `tdd-execution-workflow.md` -- TDD-aware wave execution, agent spawning, context sharing between RED and GREEN phases
- `tdd-verification-patterns.md` -- RED/GREEN/REFACTOR verification rules, compliance reporting, status determination matrix

Parse arguments from the invocation:
- `--task-group <group>` -- Filter tasks to a specific group
- `--max-parallel <n>` -- Override max concurrent agents per wave
- `--retries <n>` -- Override retry attempts per task (default: 3)

### Step 2: Validate Prerequisites

**Check tdd-tools plugin availability:**

Before loading tasks, verify that the `tdd-executor` agent is available (check for its agent file in the opencode agents directory). If the agent cannot be found, abort with a clear error:

```
ERROR: tdd-tools plugin is required for TDD task execution.

The following agents are needed but not available:
- tdd-executor (from tdd-tools) -- executes TDD task pairs with 6-phase workflow
- test-writer (from tdd-tools) -- generates tests in parallel

Install tdd-tools:
1. Add tdd-tools to your opencode agents directory
2. Restart opencode to load the agents
3. Re-run /execute-tdd-tasks

Alternatively, use /execute-tasks to run tasks without TDD enforcement.
```

Do NOT fall back to standard execution. The user explicitly requested TDD execution.

### Step 3: Load and Classify Tasks

Use `todoread` to retrieve all tasks. If `--task-group` was provided, filter to tasks where `metadata.task_group` matches.

Note: `todoread` returns the full task list with no filtering by owner or status. Scan the full list for the relevant group and pending tasks. Task metadata is embedded in the description text using the `meta:{key}:{value}` convention established by `create-tdd-tasks`.

**Classify each task by type:**

| Detection | Type | Agent |
|-----------|------|-------|
| Description contains `meta:tdd_mode:true` AND `meta:tdd_phase:red` | TDD test task | `tdd-executor` |
| Description contains `meta:tdd_mode:true` AND `meta:tdd_phase:green` | TDD implementation task | `tdd-executor` |
| No `meta:tdd_mode` or `meta:tdd_mode:false` in description | Non-TDD task | `task-executor` |

**Count and report:**
- Total tasks (pending + in_progress + completed)
- TDD pairs identified (test + implementation tasks)
- Non-TDD tasks
- Already completed tasks

**Handle edge cases:**
- **No tasks found**: Report "No tasks found for group '{group}'. Use `/create-tdd-tasks` to generate TDD task pairs from your SDD tasks." and stop.
- **All completed**: Report a summary of completed tasks including TDD compliance and stop.
- **No unblocked tasks**: Report which tasks exist and what's blocking them.

### Step 4: Build Execution Plan

Resolve `max_parallel` using precedence:
1. `--max-parallel` CLI argument (highest priority)
2. `max_parallel` in `.claude/agent-alchemy.local.md`
3. Default: 5

Resolve `retries` using precedence:
1. `--retries` CLI argument (highest priority)
2. Default: 3

Read `.claude/agent-alchemy.local.md` if it exists, for TDD-specific settings:
- `tdd.strictness` -- `strict`, `normal` (default), or `relaxed`
- `tdd.coverage-threshold` -- Minimum coverage target (default: 80)

Build the dependency graph from all pending tasks (TDD and non-TDD):

1. Collect all pending tasks and their `blockedBy` relationships (extracted from description metadata)
2. Run topological sort to assign dependency levels
3. Assign tasks to waves by dependency level (Wave 1 = no dependencies, Wave 2 = depends only on Wave 1, etc.)
4. Sort within waves by priority: critical > high > medium > low > unprioritized
5. Break ties by "unblocks most others"
6. Cap each wave at `max_parallel` tasks

**Annotate waves with TDD phase labels:**

The dependency structure from `create-tdd-tasks` naturally produces alternating test/implementation waves:

```
Wave 1: [Test-A, Test-B, Test-C]         -- RED phase (parallel test generation)
Wave 2: [Impl-A, Impl-B, Impl-C]         -- GREEN phase (parallel implementation)
Wave 3: [Test-D, Test-E, Non-TDD-F]      -- RED phase + non-TDD tasks (mixed)
Wave 4: [Impl-D, Impl-E]                  -- GREEN phase
```

**Detect circular dependencies:** If tasks remain unassigned after topological sorting, they form a cycle. Report the cycle and attempt to break at the weakest link.

**Validate TDD pair cross-references:** For each TDD task, verify its `paired_task_id` references a valid task. Log warnings for orphaned pairs.

### Step 5: Present Execution Plan and Confirm

Display the TDD execution plan:

```
EXECUTION PLAN (TDD Mode)

Tasks to execute: {count} ({tdd_pairs} TDD pairs, {non_tdd} non-TDD tasks)
Retry limit: {retries} per task
Max parallel: {max_parallel} per wave
TDD Strictness: {strict|normal|relaxed}

WAVE 1 ({n} tasks -- RED phase):
  1. [{id}] Write tests for {subject} (RED, paired: #{impl_id})
  2. [{id}] Write tests for {subject} (RED, paired: #{impl_id})

WAVE 2 ({n} tasks -- GREEN phase):
  3. [{id}] {subject} (GREEN, paired: #{test_id})
  4. [{id}] {subject} (GREEN, paired: #{test_id})

WAVE 3 ({n} tasks -- mixed):
  5. [{id}] {subject} (non-TDD)
  6. [{id}] Write tests for {subject} (RED, paired: #{impl_id})

{Additional waves...}

BLOCKED (unresolvable dependencies):
  [{id}] {subject} -- blocked by: {blocker ids}

COMPLETED:
  {count} tasks already completed
```

Use the `question` tool to confirm:

```
question:
  - "Ready to execute {count} tasks in {wave_count} waves (max {max_parallel} parallel) with TDD enforcement ({strictness} mode)?"
  options:
    - "Yes, start TDD execution" -- Proceed with the TDD execution plan above
    - "Cancel" -- Abort without executing any tasks
```

If the user selects **"Cancel"**, report "Execution cancelled. No tasks were modified." and stop.

### Step 6: Initialize Execution Directory

Generate a `task_execution_id` using three-tier resolution:
1. IF `--task-group` was provided: `{task_group}-tdd-{YYYYMMDD}-{HHMMSS}`
2. ELSE IF all open tasks share the same `metadata.task_group`: `{task_group}-tdd-{YYYYMMDD}-{HHMMSS}`
3. ELSE: `tdd-session-{YYYYMMDD}-{HHMMSS}`

**Clean stale live session:** Follow the same procedure as `execute-tasks`:
1. Check if `.claude/sessions/__live_session__/` contains leftover files
2. If found, archive to `.claude/sessions/interrupted-{YYYYMMDD}-{HHMMSS}/`
3. Reset any `in_progress` tasks from the interrupted session to `pending` (rewrite the full `todowrite` list with corrected statuses)

**Concurrency guard:** Check for `.claude/sessions/__live_session__/.lock`. Follow the same lock protocol as `execute-tasks`.

**Create session files in `.claude/sessions/__live_session__/`:**

1. **`execution_plan.md`** -- Save the TDD execution plan from Step 5
2. **`execution_context.md`** -- Initialize with TDD-extended template:
   ```markdown
   # Execution Context

   ## Project Patterns
   <!-- Discovered coding patterns, conventions, tech stack details -->

   ## Key Decisions
   <!-- Architecture decisions, approach choices made during execution -->

   ## Known Issues
   <!-- Problems encountered, workarounds applied, things to watch out for -->

   ## File Map
   <!-- Important files discovered and their purposes -->

   ## TDD Compliance
   | Task Pair | Test Task | Impl Task | RED | GREEN | Refactored | Coverage Delta |
   |-----------|-----------|-----------|-----|-------|------------|----------------|

   ## Task History
   <!-- Brief log of task outcomes with relevant context -->
   ```
3. **`task_log.md`** -- Initialize with standard table headers:
   ```markdown
   # Task Execution Log

   | Task ID | Subject | Type | Status | Attempts | Duration | Token Usage |
   |---------|---------|------|--------|----------|----------|-------------|
   ```
4. **`tasks/`** -- Empty subdirectory for archiving completed task files
5. **`progress.md`** -- Initialize with status template:
   ```markdown
   # Execution Progress (TDD Mode)
   Status: Initializing
   Wave: 0 of {total_waves}
   Max Parallel: {max_parallel}
   TDD Strictness: {strictness}
   Updated: {ISO 8601 timestamp}

   ## Active Tasks

   ## Completed This Session
   ```
6. **`execution_pointer.md`** at `$HOME/.claude/tasks/{CLAUDE_CODE_TASK_LIST_ID}/execution_pointer.md` -- Absolute path to `.claude/sessions/__live_session__/`

### Step 7: Initialize Execution Context

Read `.claude/sessions/__live_session__/execution_context.md` (created in Step 6).

If a prior execution session's context exists, look in `.claude/sessions/` for the most recent timestamped subfolder and merge relevant learnings (Project Patterns, Key Decisions, Known Issues, File Map) into the new execution context.

**Context compaction:** If Task History has 10+ entries from merged sessions, compact older entries into a summary paragraph and keep the 5 most recent in full.

### Step 8: Execute Loop

Execute tasks in waves with TDD-aware agent routing. No user interaction between waves.

#### 8a: Initialize Wave

1. Identify all unblocked tasks (pending status, all dependencies completed)
2. Sort by priority (critical > high > medium > low > unprioritized)
3. Take up to `max_parallel` tasks for this wave
4. If no unblocked tasks remain, exit the loop

#### 8b: Snapshot Execution Context

Read `.claude/sessions/__live_session__/execution_context.md` and hold as baseline for this wave. All agents read from the same snapshot.

#### 8c: Launch Wave Agents

1. Mark all wave tasks as `in_progress` by rewriting the `todowrite` list with updated statuses
2. Record `wave_start_time`
3. Update `progress.md` with active tasks
4. Launch all wave agents simultaneously using **parallel `task` tool calls in a single message turn**

<!-- RESOLVED: general_gap:bypassPermissions_mode — opencode task tool has no bypassPermissions equivalent; permissions configured in agent frontmatter. Ensure agents have appropriate permission settings. Workaround applied globally. -->

**Route each task to the correct agent:**

**For TDD tasks** (description contains `meta:tdd_mode:true`), launch the `tdd-executor` agent from `tdd-tools`:

```
task tool:
  command: tdd-executor
  prompt: |
    Execute the following TDD task.

    Task ID: {id}
    Task Subject: {subject}
    Task Description:
    ---
    {full description}
    ---

    Task Metadata:
    - Priority: {priority}
    - Complexity: {complexity}
    - TDD Phase: {tdd_phase}
    - Paired Task ID: {paired_task_id}
    - TDD Strictness: {strictness}

    CONCURRENT EXECUTION MODE
    Context Write Path: .claude/sessions/__live_session__/context-task-{id}.md
    Do NOT write to execution_context.md directly.
    Do NOT update progress.md -- the orchestrator manages it.
    Write your learnings to the Context Write Path above instead.

    {If GREEN phase, include paired test task output:}
    PAIRED TEST TASK OUTPUT:
    ---
    {test task verification report and context}
    ---
    The tests written by the paired test task are already on disk.
    Your job is to implement code that makes these tests pass (GREEN phase),
    then refactor while keeping tests green (REFACTOR phase).

    {If retry attempt:}
    RETRY ATTEMPT {n} of {max_retries}
    Previous TDD phase that failed: {RED|GREEN|REFACTOR}
    Previous attempt failed with:
    ---
    {previous verification report including TDD COMPLIANCE section}
    ---

    TDD-specific retry guidance:
    - If RED failed (tests cannot run): Check test syntax, imports, and framework config
    - If RED warned (tests passed unexpectedly): Verify tests target new behavior, not existing code
    - If GREEN failed (tests still failing): Re-read test assertions, try different implementation approach
    - If GREEN failed (regressions): Identify regression cause, fix without breaking new tests
    - If REFACTOR failed: Revert to pre-refactor state, try smaller refactoring steps

    Instructions (follow in order):
    1. Read the TDD execution and verification references
    2. Read .claude/sessions/__live_session__/execution_context.md for prior learnings
    3. Understand the task requirements and explore the codebase
    4. Execute the 6-phase TDD workflow (Understand, Write Tests, RED, Implement, GREEN, Complete)
    5. Verify TDD compliance (RED verified, GREEN verified, refactored)
    6. Update task status if PASS (mark completed via todowrite)
    7. Write learnings to .claude/sessions/__live_session__/context-task-{id}.md
    8. Return a structured verification report including TDD COMPLIANCE section
    9. Report any token/usage information available from your session
```

**For non-TDD tasks** (no `meta:tdd_mode` in description), launch the standard `task-executor` agent from `sdd-tools`:

```
task tool:
  command: task-executor
  prompt: |
    Execute the following task.

    Task ID: {id}
    Task Subject: {subject}
    Task Description:
    ---
    {full description}
    ---

    Task Metadata:
    - Priority: {priority}
    - Complexity: {complexity}
    - Source Section: {source_section}

    CONCURRENT EXECUTION MODE
    Context Write Path: .claude/sessions/__live_session__/context-task-{id}.md
    Do NOT write to execution_context.md directly.
    Do NOT update progress.md -- the orchestrator manages it.
    Write your learnings to the Context Write Path above instead.

    {If retry attempt:}
    RETRY ATTEMPT {n} of {max_retries}
    Previous attempt failed with:
    ---
    {previous verification report}
    ---
    Focus on fixing the specific failures listed above.

    Instructions (follow in order):
    1. Read the execute-tasks skill and reference files
    2. Read .claude/sessions/__live_session__/execution_context.md for prior learnings
    3. Understand the task requirements and explore the codebase
    4. Implement the necessary changes
    5. Verify against acceptance criteria
    6. Update task status if PASS (mark completed via todowrite)
    7. Write learnings to .claude/sessions/__live_session__/context-task-{id}.md
    8. Return a structured verification report
    9. Report any token/usage information available from your session
```

**Important**: Always include the `CONCURRENT EXECUTION MODE` section regardless of `max_parallel` value. All agents write to per-task context files.

#### 8d: Process Results

As each agent returns:

1. Calculate `duration` (format: <60s = `{s}s`, <60m = `{m}m {s}s`, >=60m = `{h}h {m}m {s}s`)
2. Capture token usage from `task` tool response if available
3. Determine task type label: `TDD/RED`, `TDD/GREEN`, or `non-TDD`
4. Update `task_log.md` using read-modify-write (append row):
   ```
   | {id} | {subject} | {TDD/RED|TDD/GREEN|non-TDD} | {PASS/PARTIAL/FAIL} | {attempt}/{max} | {duration} | {tokens or N/A} |
   ```
5. Log status: `[{id}] {subject}: {PASS|PARTIAL|FAIL} ({type})`
6. Update `progress.md`: move task from Active to Completed
7. **For TDD tasks**: Extract TDD compliance data from the agent's report and update the `## TDD Compliance` table in `execution_context.md`

**Context append fallback**: If the agent's report contains a `LEARNINGS:` section, write those learnings to `context-task-{id}.md` on behalf of the agent.

#### 8e: Within-Wave Retry

After processing a failed result:

1. Check retry count for the failed task
2. If retries remaining:
   - Re-launch the agent immediately with failure context (include previous report)
   - For TDD tasks, include TDD-specific retry guidance in the prompt
   - Update `progress.md`: `- [{id}] {subject} -- Retrying ({n}/{max})`
3. If retries exhausted:
   - Update task status in `todowrite` to reflect final failure state
   - Log final failure
   - **For TDD test tasks**: The paired implementation task remains blocked and will not execute

**Test-writer agent failure fallback:** If a TDD test task (RED phase) fails after all retries, the paired implementation task remains blocked. Do NOT fall back to running implementation without tests -- this would violate TDD principles.

#### 8f: Merge Context After Wave

After ALL agents in the current wave have completed (including retries):

1. Read `.claude/sessions/__live_session__/execution_context.md`
2. Read all `context-task-{id}.md` files in task ID order
3. Append each file's content to the `## Task History` section
4. **For completed TDD tasks**: Update the `## TDD Compliance` table with pair results
5. Write the complete updated `execution_context.md`
6. Delete the `context-task-{id}.md` files

**Capture test task output for GREEN phase injection:** When processing a completed test task (RED phase), store its verification report for injection into the paired implementation task's prompt in the next wave.

#### 8g: Rebuild Next Wave and Archive

1. Archive completed task files to `.claude/sessions/__live_session__/tasks/`
2. Refresh task list via `todoread`
3. Check for newly unblocked tasks (especially implementation tasks unblocked by their paired test tasks)
4. Form next wave using priority sort
5. If no unblocked tasks remain, exit the loop
6. Loop back to 8a

### Step 9: Session Summary

Write final `progress.md` with complete status. Display the TDD execution summary:

```
TDD EXECUTION SUMMARY

Tasks executed: {total attempted}
  TDD Pairs: {pair_count}
  Non-TDD: {non_tdd_count}
  Passed: {count}
  Partial: {count}
  Failed: {count} (after {total retries} total retry attempts)

TDD COMPLIANCE:
| Task Pair | Test Task | Impl Task | RED | GREEN | Refactored | Coverage Delta |
|-----------|-----------|-----------|-----|-------|------------|----------------|
| {feature} | #{test_id} ({status}) | #{impl_id} ({status}) | {Yes/No} | {Yes/No} | {Yes/No/N/A} | {+/-pct or N/A} |
...

TDD Compliance Rate: {compliant_pairs}/{total_pairs} ({percentage}%)

Waves completed: {wave_count}
Max parallel: {max_parallel}
TDD Strictness: {strictness}
Total execution time: {total_duration}
Token Usage: {total tokens or N/A}

Remaining:
  Pending: {count}
  In Progress (failed): {count}
  Blocked: {count}

{If any tasks failed:}
FAILED TASKS:
  [{id}] {subject} -- {brief failure reason} ({TDD phase if applicable})

{If newly unblocked tasks were discovered:}
NEWLY UNBLOCKED:
  [{id}] {subject} -- unblocked by completion of [{blocker_id}]
```

After displaying the summary:
1. Save `session_summary.md` to `.claude/sessions/__live_session__/` with full summary content
2. Archive the session: move all contents from `__live_session__/` to `.claude/sessions/{task_execution_id}/`
3. Leave `__live_session__/` as an empty directory
4. `execution_pointer.md` stays pointing to `__live_session__/`

### Step 10: Update CLAUDE.md

Review `.claude/sessions/{task_execution_id}/execution_context.md` for project-wide changes.

Update CLAUDE.md if the session introduced:
- New architectural patterns or conventions
- New dependencies or tech stack changes
- New development commands or workflows
- Changes to project structure
- Important design decisions

Skip if only task-specific or TDD-internal implementation details.

## Agent Routing Summary

| Task Type | Detection | Agent | Plugin | Workflow |
|-----------|-----------|-------|--------|----------|
| TDD test (RED) | `meta:tdd_mode:true`, `meta:tdd_phase:red` in description | `tdd-executor` | tdd-tools | 6-phase TDD |
| TDD impl (GREEN) | `meta:tdd_mode:true`, `meta:tdd_phase:green` in description | `tdd-executor` | tdd-tools | 6-phase TDD |
| Non-TDD | No `meta:tdd_mode` or `meta:tdd_mode:false` in description | `task-executor` | sdd-tools | 4-phase standard |

## TDD Verification Rules

See the tdd-verification-patterns reference for complete verification rules.

**Quick reference:**

| Phase | PASS | FAIL |
|-------|------|------|
| RED | All new tests fail as expected | Tests cannot run or syntax errors |
| GREEN | All tests pass, zero regressions | New tests still failing after implementation |
| REFACTOR | All tests green after cleanup | Tests broke and cannot recover |

**Strictness levels** (from `.claude/agent-alchemy.local.md` `tdd.strictness` setting):

| Level | RED Behavior | Impact |
|-------|-------------|--------|
| **strict** | Tests passing unexpectedly = FAIL | Blocks GREEN phase |
| **normal** (default) | Tests passing unexpectedly = WARN | Proceeds with warning |
| **relaxed** | Tests passing unexpectedly = INFO | Proceeds, informational only |

## Key Behaviors

- **Autonomous execution loop**: After user confirms the plan, no further prompts between tasks
- **Wave-based TDD parallelism**: Test tasks (RED) in one wave, their paired implementation tasks (GREEN) in the next. Multiple features run in parallel within a wave
- **Agent routing by metadata**: TDD tasks go to `tdd-executor`, non-TDD tasks go to `task-executor`
- **Per-task context isolation**: Each agent writes to `context-task-{id}.md`, orchestrator merges after each wave
- **Test-to-implementation context flow**: Test task output is injected into the paired implementation task's prompt via `PAIRED TEST TASK OUTPUT`
- **Within-wave retry**: Failed tasks with retries remaining re-launch immediately
- **No silent degradation**: If TDD test task fails, its paired implementation task stays blocked. Never run implementation without tests
- **TDD compliance tracking**: Per-pair tracking of RED/GREEN/REFACTOR verification in execution context
- **Configurable strictness**: `strict`, `normal`, or `relaxed` TDD enforcement via settings
- **Single-session invariant**: Only one execution session at a time, enforced by `.lock` file
- **Interrupted session recovery**: Stale sessions archived, interrupted tasks reset to `pending`
- **Task state via todowrite/todoread**: Task status is managed by rewriting the full task list via todowrite; retrieve with todoread and scan for metadata embedded in description text

## Example Usage

### Execute all TDD tasks
```
/execute-tdd-tasks
```

### Execute TDD tasks for a specific group
```
/execute-tdd-tasks --task-group user-authentication
```

### Execute with limited parallelism
```
/execute-tdd-tasks --max-parallel 2
```

### Execute sequentially (no concurrency)
```
/execute-tdd-tasks --max-parallel 1
```

### Execute with custom retries
```
/execute-tdd-tasks --retries 1
```

### Execute group with custom parallelism and retries
```
/execute-tdd-tasks --task-group payments --max-parallel 3 --retries 1
```

## Reference Files

The following reference files must be inlined into this skill or registered in opencode.json under the instructions array (opencode has no reference_dir equivalent):

<!-- TODO: Inline or register via opencode.json instructions: tdd-execution-workflow.md -- TDD-aware wave execution, agent spawning, context sharing between RED and GREEN phases -->
<!-- TODO: Inline or register via opencode.json instructions: tdd-verification-patterns.md -- RED/GREEN/REFACTOR verification rules, compliance reporting, status determination matrix -->
~~~

## Fidelity Report

| Mapping Type | Count | Weight | Contribution |
|-------------|-------|--------|-------------|
| Direct | 12 | 1.0 | 12.0 |
| Workaround | 7 | 0.7 | 4.9 |
| TODO | 4 | 0.2 | 0.8 |
| Omitted | 3 | 0.0 | 0.0 |
| **Total** | **26** | | **17.7** |

**Score:** 17.7 / 26 * 100 = **68%**

**Notes:** Score is moderate due to four TODO items (two reference file gaps and two bypassPermissions mode occurrences) and three omitted fields (allowed-tools, disable-model-invocation, arguments). The core orchestration logic — all 10 steps, wave execution, TDD compliance tracking, agent routing, and the confirmation dialog — converts cleanly. The primary functional degradation is the TaskCreate/TaskUpdate/TaskList/TaskGet -> todowrite/todoread partial mappings (all globally cached from prior waves) and the absence of a reference_dir in opencode requiring manual inlining of two reference files.

## Decisions

| Feature | Decision Type | Original | Converted | Rationale | Confidence | Resolution Mode |
|---------|-------------|----------|-----------|-----------|------------|----------------|
| name field | omitted | `name: execute-tdd-tasks` | Derived from filename `execute-tdd-tasks.md` | opencode derives skill name from filename; embedded:filename mapping | high | auto |
| argument-hint field | relocated | `argument-hint: "[--task-group <group>] ..."` | Arguments section in skill body | opencode uses $ARGUMENTS / $1, $2 in body; embedded:body mapping | high | auto |
| user-invocable field | direct | `user-invocable: true` | `user-invocable: true` | Direct 1:1 mapping | high | individual |
| disable-model-invocation field | workaround | `disable-model-invocation: false` | Noted in description (user-only constraint) | Maps to null; since value is false (no-op), cosmetic. Documented per cached decision | high | cached |
| allowed-tools field | omitted | 12-tool list | Omitted entirely | No per-skill tool restrictions in opencode; cosmetic gap per cached decision | high | cached |
| arguments field | omitted | YAML arguments array | Argument descriptions moved to body prose | No opencode equivalent for structured argument definitions in skill frontmatter | high | auto |
| description field | workaround | description text | description + primary-agent note appended | Added note about question tool primary-agent restriction per cached gap decision | high | cached |
| TaskList tool | workaround | `TaskList` | `todoread` + full list scan | Partial mapping; returns full list, no filtering by owner/status. Metadata extracted from description text. Cached from skill-sdd-tools-create-tasks | high | cached |
| TaskCreate tool | workaround | `TaskCreate` | `todowrite` with metadata in description | Session-scoped scratchpad only; no structured metadata fields. Cached from skill-sdd-tools-create-tasks | high | cached |
| TaskUpdate tool | workaround | `TaskUpdate` | `todowrite` full rewrite with updated status | Same todowrite tool; must rewrite complete list to update one task. Cached from skill-sdd-tools-create-tasks | high | cached |
| TaskGet tool | workaround | `TaskGet` | `todoread` + scan for task_uid in description | No per-task retrieval by ID. Cached from skill-sdd-tools-create-tasks | high | cached |
| AskUserQuestion (Step 5 confirmation) | direct | AskUserQuestion YAML block | `question` tool equivalent syntax | Direct mapping; question tool supports 1-8 questions with 2-8 options for primary agents | high | individual |
| tdd-executor agent routing | workaround | `Task subagent_type: tdd-executor` | `task command: tdd-executor` | opencode uses command field for named agent routing; cross-plugin supported via unified registry | high | individual |
| task-executor agent routing | workaround | `Task subagent_type: task-executor` | `task command: task-executor` | opencode uses command field for named agent routing | high | individual |
| tdd-execution-workflow.md reference | TODO | `Read ${CLAUDE_PLUGIN_ROOT}/skills/execute-tdd-tasks/references/tdd-execution-workflow.md` | TODO comment + inline instruction | opencode has no reference_dir; files must be inlined or loaded via opencode.json instructions array. Cached from skill-tdd-tools-analyze-coverage | medium | cached |
| tdd-verification-patterns.md reference | TODO | `Read ${CLAUDE_PLUGIN_ROOT}/skills/execute-tdd-tasks/references/tdd-verification-patterns.md` | TODO comment + inline instruction | Same reference_dir null limitation | medium | cached |
| bypassPermissions mode (tdd-executor) | TODO | `mode: bypassPermissions` | UNRESOLVED inline marker | opencode task tool has no bypassPermissions equivalent; permissions configured in agent frontmatter | low | individual |
| bypassPermissions mode (task-executor) | TODO | `mode: bypassPermissions` | UNRESOLVED inline marker | Same limitation; no runtime permission bypass mechanism | low | individual |
| Read tool | direct | `Read` | `read` | Direct 1:1 mapping | high | auto |
| Write tool | direct | `Write` | `write` | Direct 1:1 mapping | high | auto |
| Edit tool | direct | `Edit` | `edit` | Direct 1:1 mapping | high | auto |
| Glob tool | direct | `Glob` | `glob` | Direct 1:1 mapping | high | auto |
| Grep tool | direct | `Grep` | `grep` | Direct 1:1 mapping | high | auto |
| Bash tool | direct | `Bash` | `bash` | Direct 1:1 mapping | high | auto |
| Task tool | direct | `Task` | `task` | Direct 1:1 mapping | high | auto |
| Task metadata detection (tdd_mode, tdd_phase) | workaround | `metadata.tdd_mode`, `metadata.tdd_phase` structured fields | `meta:tdd_mode:value` pattern in description text | todowrite/todoread have no structured metadata fields; metadata embedded in description using established convention from cached create-tasks decision | high | cached |

## Gaps

| Feature | Reason | Severity | Workaround | User Acknowledged |
|---------|--------|----------|------------|-------------------|
| allowed-tools per-skill restrictions | opencode has no per-skill tool restriction mechanism; tool permissions are agent-level only | cosmetic | Omit field; configure tool permissions in agent frontmatter if needed | false |
| disable-model-invocation | Not supported in opencode; skill tool always available to model | cosmetic | Value is false so no-op; document user-only intent in description | false |
| reference_dir (tdd-execution-workflow.md) | opencode has no reference_dir equivalent; reference files cannot be auto-loaded | functional | Inline reference content into skill body, or register in opencode.json instructions array | false |
| reference_dir (tdd-verification-patterns.md) | opencode has no reference_dir equivalent | functional | Inline reference content into skill body, or register in opencode.json instructions array | false |
| bypassPermissions agent launch mode | opencode task tool has no bypassPermissions parameter; permission mode cannot be set at call time | functional | Configure agent-level permissions in tdd-executor and task-executor agent frontmatter using the permission field | false |
| TaskCreate/TaskUpdate structured metadata | todowrite is session-scoped with no structured metadata fields; no task dependencies, owners, or filtering | functional | Embed metadata as `meta:key:value` tokens in description text; scan full todoread list for filtering (established convention from prior waves) | false |
| TaskList/TaskGet per-field filtering | todoread returns all tasks; no filtering by owner, status, or metadata field | functional | Full list scan with pattern matching on description text | false |
| arguments frontmatter block | No opencode equivalent for structured argument definition in skill frontmatter | cosmetic | Describe arguments in skill body prose | false |

## Unresolved Incompatibilities

| Group Key | Feature | Severity | Category | Reason | Suggested Workaround | Confidence | Affected Locations |
|-----------|---------|----------|----------|--------|---------------------|------------|-------------------|
| general_gap:bypassPermissions_mode | bypassPermissions agent launch mode | functional | general_gap | opencode task tool has no bypassPermissions parameter. There is no mechanism to bypass tool permissions at call time. | Configure appropriate permissions in agent frontmatter (tdd-executor and task-executor) using the permission field with allow settings for required tools. This is a one-time agent config change, not a per-call setting. | medium | 2 locations (8c tdd-executor launch, 8c task-executor launch) |
