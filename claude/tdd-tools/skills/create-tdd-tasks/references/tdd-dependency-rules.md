# TDD Dependency Rules

This reference documents how TDD task pairs are inserted into existing SDD dependency chains, preserving all original relationships while enforcing test-first ordering. These rules are applied by the `create-tdd-tasks` skill after SDD tasks have been generated by `create-tasks`.

---

## Core Rule: Test Blocks Implementation

The fundamental dependency rule for every TDD pair:

```
Test Task (red) --blocks--> Implementation Task (green)
```

The test task must be completed before the paired implementation task can start. This enforces the RED phase (write failing tests) before the GREEN phase (implement to make tests pass).

### Rule Application

When creating a TDD pair for implementation task `#N`:

1. Create test task `#T` with `tdd_phase: "red"` and `paired_task_id: N`
2. Update implementation task `#N` with `tdd_phase: "green"` and `paired_task_id: T`
3. Set dependency: `TaskUpdate(taskId: N, addBlockedBy: [T])`

The test task inherits the same `blockedBy` dependencies as the original implementation task. This positions the test task at exactly the same point in the dependency chain where the original task was, with the implementation task now one step behind.

---

## Preserving Existing SDD Dependencies

TDD pairs are INSERTED into the existing dependency chain, not replacing it. The original SDD dependency relationships are preserved.

### Insertion Algorithm

Given an existing SDD chain:

```
Before: A --> B --> C
         (A blocks B, B blocks C)
```

After TDD pair insertion:

```
After: A --> Test-A --> A' --> Test-B --> B' --> Test-C --> C'
```

Where:
- `Test-X` is the new test task for task `X`
- `X'` is the original task `X` (now with `tdd_phase: "green"`)
- `A` has no test pair only if it is skipped (e.g., a config task)

### Step-by-Step Insertion

For each task in the dependency chain:

**Step 1: Identify the task's upstream dependencies (blockedBy)**

```
Task B is blockedBy: [A]
```

**Step 2: Create the test task with the SAME upstream dependencies**

```
Test-B is blockedBy: [A]  (same as original B)
```

**Step 3: Add the test task as a new dependency of the implementation task**

```
B is now blockedBy: [A, Test-B]
```

**Step 4: For downstream tasks, no changes needed**

```
C is still blockedBy: [B]  (unchanged — C depends on B, not Test-B)
```

The result: the test task slots in before the implementation task at the same dependency level, and downstream tasks still depend on the implementation task completing.

---

## Chain Transformation Examples

### Example 1: Linear SDD Chain

```
Before:
  Model Task (#1) --> API Task (#2) --> UI Task (#3)

After TDD pair insertion:
  Test-Model (#4) --> Model Task (#1) --> Test-API (#5) --> API Task (#2) --> Test-UI (#6) --> UI Task (#3)

Dependencies:
  #4 blockedBy: []           (root task — no upstream deps)
  #1 blockedBy: [#4]         (model blocked by its test)
  #5 blockedBy: [#1]         (test-API inherits model's position as API's upstream)
  #2 blockedBy: [#1, #5]     (API blocked by model AND its own test)
  #6 blockedBy: [#2]         (test-UI inherits API's position as UI's upstream)
  #3 blockedBy: [#2, #6]     (UI blocked by API AND its own test)
```

### Example 2: Parallel Feature Branches

```
Before:
  User Model (#1) --> Login API (#2)
  User Model (#1) --> Profile API (#3)

After TDD pair insertion:
  Test-Model (#4)   --> User Model (#1) --> Test-Login (#5)   --> Login API (#2)
                                        --> Test-Profile (#6) --> Profile API (#3)

Dependencies:
  #4 blockedBy: []           (root)
  #1 blockedBy: [#4]         (model blocked by its test)
  #5 blockedBy: [#1]         (test-login inherits model dependency)
  #2 blockedBy: [#1, #5]     (login blocked by model AND its test)
  #6 blockedBy: [#1]         (test-profile inherits model dependency)
  #3 blockedBy: [#1, #6]     (profile blocked by model AND its test)
```

### Example 3: Shared Dependencies

```
Before:
  Auth Setup (#1) --> User CRUD (#2) --> Dashboard UI (#3)
  Auth Setup (#1) --> Settings API (#4)

After TDD pair insertion:
  Test-Auth (#5)  --> Auth Setup (#1)  --> Test-CRUD (#6)     --> User CRUD (#2)     --> Test-Dashboard (#7) --> Dashboard UI (#3)
                                       --> Test-Settings (#8) --> Settings API (#4)

Dependencies:
  #5 blockedBy: []
  #1 blockedBy: [#5]
  #6 blockedBy: [#1]
  #2 blockedBy: [#1, #6]
  #7 blockedBy: [#2]
  #3 blockedBy: [#2, #7]
  #8 blockedBy: [#1]
  #4 blockedBy: [#1, #8]
```

---

## Cross-Feature Dependency Preservation

When multiple features share dependencies (shared data models, shared services), TDD pair insertion preserves these cross-feature relationships.

### Shared Model Example

```
Before:
  User Model (#1) --> Auth Feature (#2)
  User Model (#1) --> Notification Feature (#3)
  Order Model (#4) --> Payment Feature (#5)

After:
  Test-User (#6) --> User Model (#1) --> Test-Auth (#7) --> Auth Feature (#2)
                                     --> Test-Notif (#8) --> Notification Feature (#3)
  Test-Order (#9) --> Order Model (#4) --> Test-Payment (#10) --> Payment Feature (#5)
```

Cross-feature dependencies are not modified. The TDD insertion only adds dependencies within each task's own pair and inherits the original task's upstream dependencies.

### Cross-Feature Dependency Rule

If Task B (in Feature X) depends on Task A (in Feature Y):

```
Before: A(Feature-Y) --> B(Feature-X)
After:  Test-A --> A(Feature-Y) --> Test-B --> B(Feature-X)
```

The cross-feature dependency `A --> B` is preserved. Test-B inherits A as a dependency because B originally depended on A.

---

## Circular Dependency Detection

After inserting TDD pairs, the dependency graph may contain circular dependencies that did not exist in the original SDD chain. This is rare but possible when cross-feature dependencies create complex graphs.

### Detection Procedure

After all TDD pairs are inserted:

1. **Build the full dependency graph** from all tasks (original + new test tasks)
2. **Run topological sort** on the graph
3. **If topological sort fails**, a cycle exists
4. **Identify the cycle** by tracing back-edges in the graph

### Common Circular Dependency Patterns

**Pattern: Mutual feature dependency after TDD insertion**

```
Before (valid):
  Feature-A (#1) --> Feature-B (#2) [A blocks B]
  Feature-B (#2) --> Feature-A-Part2 (#3) [B blocks A-Part2]

After (may create cycle if A-Part2 is paired with same test as A):
  Test-A (#4) --> Feature-A (#1) --> Test-B (#5) --> Feature-B (#2)
  Feature-B (#2) --> Test-A-Part2 (#6) --> Feature-A-Part2 (#3)
  (No cycle here — #3 is a different task from #1)
```

**Pattern: Self-referencing dependency (always a bug)**

```
Task-A blockedBy: [Task-A]  <-- Invalid, should never occur
```

### Weakest-Link Breaking Strategy

When a circular dependency is detected after TDD pair insertion:

**Step 1: Identify all tasks in the cycle**

```
Cycle: #4 --> #1 --> #5 --> #2 --> #6 --> #3 --> #4
```

**Step 2: Score each dependency link**

| Score Factor | Weight | Description |
|-------------|--------|-------------|
| TDD pair link | 1 (weakest) | `test --> impl` within a pair |
| Same-feature cross-layer | 2 | Data model --> API within same feature |
| Cross-feature dependency | 3 (strongest) | Explicit spec dependency across features |

**Step 3: Break the cycle at the weakest link**

Remove the dependency with the lowest score. In most cases, this will be a TDD pair link where the test task can safely be made independent of the cycle.

**Step 4: Log a warning**

```
WARNING: Circular dependency detected after TDD pair insertion.
Cycle: #4 -> #1 -> #5 -> #2 -> #6 -> #3 -> #4
Broken at: #4 (Test-A) no longer blocked by #3 (Feature-A-Part2)
Reason: TDD pair link is weakest (score: 1)
Impact: Test-A may run before Feature-A-Part2 completes. Manual review recommended.
```

**Step 5: Flag for human review**

Add `needs_review: true` and `circular_dep_break: true` to the metadata of the task whose dependency was removed.

### Prevention

Most circular dependencies can be prevented by:
1. Ensuring TDD test tasks only inherit upstream dependencies, never downstream
2. Not creating test tasks for tasks that are themselves test tasks
3. Treating the original SDD chain as a DAG (directed acyclic graph) — if the original chain has no cycles, TDD insertion should not introduce them unless cross-feature dependencies are bidirectional

---

## `--task-group` Filtering

The `create-tdd-tasks` skill supports `--task-group` filtering to convert only tasks in a specified group.

### Behavior

When `--task-group` is provided:

1. **Filter tasks**: Only process tasks where `metadata.task_group` matches the argument
2. **Create pairs for filtered tasks only**: Do not create test tasks for tasks outside the group
3. **Preserve cross-group dependencies**: If a filtered task depends on a task outside the group, that dependency is preserved but no test task is created for the external dependency

### Example

```
All tasks:
  #1: Create User model          [group: user-auth]
  #2: Implement login endpoint    [group: user-auth]
  #3: Create Order model          [group: payments]
  #4: Implement checkout endpoint [group: payments]
  #4 is blockedBy: [#1]  (checkout needs user model)

Command: /create-tdd-tasks --task-group user-auth

Result:
  #5: Write tests for Create User model        [group: user-auth, tdd_phase: red]
  #1: Create User model                         [group: user-auth, tdd_phase: green]
  #6: Write tests for Implement login endpoint  [group: user-auth, tdd_phase: red]
  #2: Implement login endpoint                  [group: user-auth, tdd_phase: green]
  #3: Create Order model                        [group: payments]   <-- untouched
  #4: Implement checkout endpoint               [group: payments]   <-- untouched
```

### Cross-Group Dependencies with Filtering

When a filtered task depends on a non-filtered task, the dependency is preserved as-is:

```
#2 (user-auth) blockedBy: [#1 (user-auth)]
#4 (payments) blockedBy: [#1 (user-auth)]

After --task-group user-auth:
  #5 (Test-User) blockedBy: []
  #1 (User Model) blockedBy: [#5]        <-- TDD pair dependency added
  #6 (Test-Login) blockedBy: [#1]
  #2 (Login) blockedBy: [#1, #6]         <-- TDD pair dependency added
  #4 (Checkout) blockedBy: [#1]          <-- unchanged, cross-group dep preserved
```

### No-Group Tasks

Tasks without `metadata.task_group` are excluded from `--task-group` filtered runs. They are never modified unless no `--task-group` filter is specified.

---

## Wave Impact Analysis

TDD pair insertion approximately doubles the number of tasks, which affects wave-based execution planning.

### Before TDD (3 waves)

```
Wave 1: Model Task (no deps)
Wave 2: API Task (depends on Model)
Wave 3: UI Task (depends on API)
```

### After TDD (6 waves in sequential worst case)

```
Wave 1: Test-Model (no deps)
Wave 2: Model Task (depends on Test-Model)
Wave 3: Test-API (depends on Model)
Wave 4: API Task (depends on Test-API)
Wave 5: Test-UI (depends on API)
Wave 6: UI Task (depends on Test-UI)
```

### Parallelism Recovery

With parallel features, waves can contain multiple tasks:

```
Wave 1: Test-Model-A, Test-Model-B       (parallel test generation)
Wave 2: Model-A, Model-B                 (parallel implementation)
Wave 3: Test-API-A, Test-API-B           (parallel test generation)
Wave 4: API-A, API-B                     (parallel implementation)
```

This is the "strategic parallelism" described in the spec: test generation is parallelized across features, while RED-GREEN sequencing is maintained within each feature's task pair.

---

## Dependency Validation Checklist

After all TDD pairs are inserted, validate:

| Check | Rule | Action on Failure |
|-------|------|-------------------|
| No circular dependencies | Topological sort succeeds | Break at weakest link, flag for review |
| Every test task blocks its pair | `paired_task_id` cross-references are valid | Fix missing dependencies |
| Original SDD deps preserved | All pre-existing `blockedBy` relationships still exist | Re-add missing dependencies |
| No orphan test tasks | Every test task has a valid `paired_task_id` | Remove orphan or find pair |
| No double-paired tasks | Each impl task has at most one test pair | Remove duplicate, keep first |
| Task group consistency | Test tasks inherit `task_group` from paired impl task | Set `task_group` on test task |
