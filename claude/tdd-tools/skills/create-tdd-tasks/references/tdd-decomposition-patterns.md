# TDD Decomposition Patterns

This reference documents how to transform SDD implementation tasks into TDD task pairs. For each implementation task generated by `create-tasks`, a paired test task is created that must complete first, enforcing test-first development at the pipeline level.

---

## Core Concept: Task Pairing

Every SDD implementation task becomes a TDD pair:

```
Original SDD Task
    |
    +-- Test Task (tdd_phase: "red")    <-- Write tests first
    |       |
    +-- Implementation Task (tdd_phase: "green")  <-- Then implement
```

The test task BLOCKS the implementation task. The implementation task cannot start until the test task is completed.

---

## Test Task Generation

### Naming Convention

Test tasks follow a consistent naming pattern derived from the original task subject:

| Original Subject | Test Task Subject |
|-----------------|-------------------|
| Create User data model | Write tests for Create User data model |
| Implement POST /auth/login endpoint | Write tests for Implement POST /auth/login endpoint |
| Build login form component | Write tests for Build login form component |
| Implement password validation logic | Write tests for Implement password validation logic |

**Format**: `"Write tests for {original task subject}"`

### Test Task Description Structure

The test task description is generated by converting the original task's acceptance criteria into test descriptions:

```markdown
Write failing tests for: {original task subject}

Test file: {inferred test file path}
Test framework: {detected framework}
Original task: #{original_task_id}

**Test Descriptions:**

_From Functional Criteria:_
- [ ] Test that {criterion rephrased as test assertion}
- [ ] Test that {criterion rephrased as test assertion}

_From Edge Cases:_
- [ ] Test that {edge case rephrased as test assertion}

_From Error Handling:_
- [ ] Test that {error scenario rephrased as test assertion}

_From Performance:_ (if applicable)
- [ ] Test that {performance target as measurable assertion}

**Acceptance Criteria:**

_Functional:_
- [ ] All test descriptions converted into runnable test functions
- [ ] Tests follow project test conventions (naming, structure, fixtures)
- [ ] Tests are discoverable by the test runner
- [ ] Tests fail when run without implementation (RED state)

_Edge Cases:_
- [ ] Tests handle import errors gracefully when implementation module does not exist

_Error Handling:_
- [ ] Test file is syntactically valid even when implementation is missing

Source: {original source reference}
```

### Criteria-to-Test Conversion Examples

**Functional criterion:**
```
Original: "- [ ] Valid credentials return JWT token"
Test:     "- [ ] Test that valid credentials return a JWT token with correct structure"
```

**Edge case criterion:**
```
Original: "- [ ] Handle case-insensitive email matching"
Test:     "- [ ] Test that email matching is case-insensitive (user@EXAMPLE.com matches user@example.com)"
```

**Error handling criterion:**
```
Original: "- [ ] 401 for invalid credentials (generic message)"
Test:     "- [ ] Test that invalid credentials return 401 with generic error message"
```

**Performance criterion:**
```
Original: "- [ ] Response time < 200ms (P95)"
Test:     "- [ ] Test that response time is under 200ms at P95 (benchmark or timing assertion)"
```

---

## Layer-to-Test-Type Mapping

TDD inverts the standard SDD layer ordering. In SDD, the pattern is `Data -> API -> UI -> Tests`. In TDD, tests come first for each layer:

| SDD Task Layer | SDD Order | TDD Paired Test Type | TDD Order |
|---------------|-----------|---------------------|-----------|
| Data Model | Layer 1 (first) | Unit + Integration tests | Test-Data before Data |
| API/Endpoint | Layer 2 | Integration tests | Test-API before API |
| Business Logic | Layer 3 | Unit tests | Test-Logic before Logic |
| UI/Frontend | Layer 4 | Component tests | Test-UI before UI |
| Test Tasks | Layer 5 (last) | N/A (already tests) | Skipped |

### Layer Pairing Details

#### Data Model Tasks

Paired with **unit + integration** test tasks.

```
Test task includes:
- Unit tests for schema validation, field types, constraints, default values
- Unit tests for model methods and computed properties
- Integration tests for database persistence and retrieval
- Integration tests for relationship integrity and cascades
```

#### API/Endpoint Tasks

Paired with **integration** test tasks.

```
Test task includes:
- Integration tests for success responses (200, 201) with valid input
- Integration tests for error responses (400, 401, 403, 404, 500)
- Integration tests for input validation and sanitization
- Integration tests for authentication/authorization requirements
```

#### Business Logic Tasks

Paired with **unit** test tasks.

```
Test task includes:
- Unit tests for core logic with mocked dependencies
- Unit tests for edge cases and boundary conditions
- Unit tests for error handling and exception paths
- Unit tests for validation rules
```

#### UI/Frontend Tasks

Paired with **component** test tasks.

```
Test task includes:
- Component tests for render states (loading, empty, error, success)
- Component tests for user interactions (clicks, inputs, forms)
- Component tests for accessibility (ARIA, keyboard navigation)
```

### Skipped Task Types

The following SDD task types do NOT get TDD pairs:

| Task Type | Reason |
|-----------|--------|
| Test Tasks | Already tests — pairing would create tests-for-tests |
| Configuration Tasks | Infrastructure setup, no testable behavior |
| Documentation Tasks | Non-code deliverables |
| Tasks with `tdd_mode: true` | Already a TDD task (prevents double-pairing) |

---

## Metadata Additions

### Test Task Metadata

```yaml
metadata:
  tdd_mode: true           # Marks this task as part of a TDD pair
  tdd_phase: "red"         # This is the test-writing phase
  paired_task_id: "12"     # ID of the paired implementation task
  # All original metadata is preserved:
  priority: high           # Inherited from original task
  complexity: S            # Typically S or M (test files are smaller)
  source_section: "7.3"    # Inherited from original task
  spec_path: "specs/SPEC-Auth.md"
  feature_name: "User Authentication"
  task_uid: "specs/SPEC-Auth.md:user-auth:model:001:red"  # Original UID + :red
  task_group: "user-authentication"  # Inherited from original task
```

### Implementation Task Metadata Updates

The original implementation task receives additional metadata:

```yaml
metadata:
  tdd_mode: true           # Marks this task as part of a TDD pair
  tdd_phase: "green"       # This is the implementation phase
  paired_task_id: "15"     # ID of the paired test task
  # All existing metadata preserved:
  task_uid: "specs/SPEC-Auth.md:user-auth:model:001"  # Original UID unchanged
```

### Metadata Field Reference

| Field | Type | Values | Purpose |
|-------|------|--------|---------|
| `tdd_mode` | boolean | `true` | Identifies tasks that are part of a TDD pair |
| `tdd_phase` | string | `"red"`, `"green"` | Which TDD phase this task represents |
| `paired_task_id` | string | task ID | Links the two tasks in a pair |

### Task UID Convention

Test tasks append `:red` to the original task's `task_uid`:

```
Original:  specs/SPEC-Auth.md:user-auth:model:001
Test pair: specs/SPEC-Auth.md:user-auth:model:001:red
```

This preserves the merge tracking capability — both the test task and the original implementation task can be matched back to the original spec requirement.

---

## Tasks Without Acceptance Criteria

Some implementation tasks may lack structured acceptance criteria (no `**Acceptance Criteria:**` section). For these tasks, generate basic tests from the task subject and description.

### Detection

A task lacks acceptance criteria when:
1. No `**Acceptance Criteria:**` header in the description
2. No `_Functional:_` criteria section
3. Description is brief or high-level

### Basic Test Generation Strategy

**Step 1: Parse the subject for intent**

| Subject Pattern | Test Strategy |
|----------------|---------------|
| "Create {X}" | Test that X exists with expected structure |
| "Implement {X}" | Test that X produces expected output for known input |
| "Add {X}" | Test that X integrates correctly with the existing system |
| "Build {X}" | Test that X renders or initializes without errors |
| "Configure {X}" | Test that configuration values are applied correctly |

**Step 2: Extract testable statements from description**

Look for implicit requirements:
- "should..." -> test assertion
- "must..." -> test assertion
- "returns..." -> test expected output
- "validates..." -> test validation rules
- "handles..." -> test error handling
- Field lists -> test field existence and types
- Endpoint definitions -> test request/response

**Step 3: Generate minimal test descriptions**

```markdown
Write failing tests for: {original task subject}

Test file: {inferred test file path}
Test framework: {detected framework}
Original task: #{original_task_id}

**Test Descriptions:**

_Inferred from task description:_
- [ ] Test that {subject entity} can be created/initialized
- [ ] Test that {subject entity} has expected structure/interface
- [ ] Test that {described behavior} works as described
- [ ] Test that {described behavior} handles invalid input gracefully

**Acceptance Criteria:**

_Functional:_
- [ ] At least one meaningful test written per described behavior
- [ ] Tests follow project conventions
- [ ] Tests fail when run without implementation (RED state)

Source: Generated from task #{original_task_id} description
```

---

## Merge Mode Detection

When `create-tdd-tasks` is run on a task list that already has TDD pairs, it must detect and handle existing pairs to avoid duplication.

### Detection Algorithm

A task already has a TDD pair if ANY of the following are true:

1. **Metadata check**: Task has `tdd_mode: true` in metadata
2. **Paired task check**: Task has `paired_task_id` in metadata, and the paired task exists
3. **UID check**: A task with `task_uid` ending in `:red` exists that matches the implementation task's `task_uid + ":red"`
4. **Subject check**: A task with subject `"Write tests for {this task's subject}"` exists in the same `task_group`

### Merge Behavior

| Existing Pair Status | Action |
|---------------------|--------|
| Both tasks `pending` | Skip — pair already exists, no changes needed |
| Test task `completed`, impl `pending` | Skip — pair is progressing normally |
| Test task `completed`, impl `completed` | Skip — pair is fully done |
| Test task `completed`, impl `in_progress` | Skip — pair is in progress |
| Test task `pending`, impl `completed` | Flag as anomaly — impl completed without tests. Ask user |
| Only impl exists, test missing | Treat as unpaired — create the test task |
| Only test exists, impl missing | Flag as orphan — ask user if impl task was deleted |

### Merge Report

After detection, report to user:

```
TDD PAIR STATUS:
- {n} tasks already have TDD pairs (skipped)
- {m} tasks need TDD pairs (will create)
- {k} anomalies detected (need user input)
```

---

## Complete Pairing Example

### Before (SDD tasks from create-tasks)

```
#1: Create User data model          [priority: critical, layer: data]
#2: Implement POST /auth/login      [priority: critical, layer: api]
#3: Build login form component      [priority: high, layer: ui]
#4: Add auth integration tests      [priority: medium, layer: test]
```

### After (TDD pairs inserted by create-tdd-tasks)

```
#5: Write tests for Create User data model      [tdd_phase: red,   paired: #1]
#1: Create User data model                       [tdd_phase: green, paired: #5]
#6: Write tests for Implement POST /auth/login   [tdd_phase: red,   paired: #2]
#2: Implement POST /auth/login                   [tdd_phase: green, paired: #6]
#7: Write tests for Build login form component   [tdd_phase: red,   paired: #3]
#3: Build login form component                   [tdd_phase: green, paired: #7]
#4: Add auth integration tests                   [skipped — already a test task]
```

Dependencies after pairing:
```
#5 (Test-Model) blocks #1 (Model)
#1 (Model) blocks #6 (Test-API)
#6 (Test-API) blocks #2 (API)
#2 (API) blocks #7 (Test-UI)
#7 (Test-UI) blocks #3 (UI)
#4 (Integration Tests) blocked by #1, #2, #3
```
